 We looked at using locks to provide mutual exclusion
 Locks work, but they have some drawbacks when
critical sections are long
◆ Spinlocks – inefficient
◆ Disabling interrupts – can miss or delay important events
 Instead, we want synchronization mechanisms that
◆ Block waiters
◆ Leave interrupts enabled inside the critical section
 Look at two common high-level mechanisms
◆ Semaphores: binary (mutex) and counting
◆ Monitors: mutexes and condition variables
 Use them to solve common synchronization problems

 Semaphores are another data structure that provides
mutual exclusion to critical sections
◆ Block waiters, interrupts enabled within CS
◆ Described by Dijkstra in THE system in 1968
 Semaphores can also be used as atomic counters
◆ More later
 Semaphores support two operations:
◆ wait(semaphore): decrement, block until semaphore is open
» Also P(), after the Dutch word for test, or down()
◆ signal(semaphore): increment, allow another thread to enter
» Also V() after the Dutch word for increment, or up()


Blocking in Semaphores
 Associated with each semaphore is a queue of waiting
processes
 When wait() is called by a thread:
◆ If semaphore is open, thread continues
◆ If semaphore is closed, thread blocks on queue
 Then signal() opens the semaphore:
◆ If a thread is waiting on the queue, the thread is unblocked
◆ If no threads are waiting on the queue, the signal is
remembered for the next thread
» In other words, signal() has “history” (c.f. condition vars later)
» This “history” is a counter


Semaphore Types
 Semaphores come in two types
 Mutex semaphore
◆ Represents single access to a resource
◆ Guarantees mutual exclusion to a critical section
 Counting semaphore
◆ Represents a resource with many units available, or a
resource that allows certain kinds of unsynchronized
concurrent access (e.g., reading)
◆ Multiple threads can pass the semaphore
◆ Number of threads determined by the semaphore “count”
» mutex has count = 1, counting has count = N
